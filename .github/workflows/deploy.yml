name: Deploy

on:
  push:
    branches:
      - main
      - develop
  workflow_run:
    workflows: ["Build"]
    types:
      - completed
    branches:
      - main
      - develop

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: smartcloudops-ai
  ECS_CLUSTER: smartcloudops-cluster
  ECS_SERVICE: smartcloudops-service
  S3_BUCKET: smartcloudops-static

permissions:
  contents: read
  id-token: write
  pull-requests: write
  issues: write

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_STAGING }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: staging-${{ github.sha }}
        run: |
          echo "üèóÔ∏è Building and pushing Docker image to ECR..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "‚úÖ Docker image pushed to ECR"

      - name: Deploy to ECS
        run: |
          echo "üöÄ Deploying to ECS staging..."
          aws ecs update-service \
            --cluster $ECS_CLUSTER-staging \
            --service $ECS_SERVICE-staging \
            --force-new-deployment
          echo "‚úÖ ECS service updated"

      - name: Wait for deployment to complete
        run: |
          echo "‚è≥ Waiting for deployment to complete..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER-staging \
            --services $ECS_SERVICE-staging
          echo "‚úÖ Deployment completed"

      - name: Run smoke tests
        run: |
          echo "üß™ Running smoke tests on staging..."
          # Resolve ALB DNS name for the ECS service
          TARGET_GROUP_ARN=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER-staging \
            --services $ECS_SERVICE-staging \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text)
          ALB_ARN=$(aws elbv2 describe-target-groups \
            --target-group-arns "$TARGET_GROUP_ARN" \
            --query 'TargetGroups[0].LoadBalancerArns[0]' \
            --output text)
          SERVICE_URL=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns "$ALB_ARN" \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          # Wait for service to be ready
          sleep 60
          
          # Test health endpoint
          curl -f http://$SERVICE_URL/health || echo "‚ö†Ô∏è Health check failed"
          
          # Test basic functionality
          curl -f http://$SERVICE_URL/ || echo "‚ö†Ô∏è Root endpoint check failed"
          
          echo "‚úÖ Smoke tests completed"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Build frontend
        working-directory: frontend
        run: |
          npm ci
          npm run build

      - name: Deploy frontend to S3
        run: |
          echo "üì¶ Deploying frontend to S3..."
          aws s3 sync frontend/build/ s3://$S3_BUCKET-staging/ --delete
          aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID_STAGING }} \
            --paths "/*" || echo "‚ö†Ô∏è CloudFront invalidation failed"
          echo "‚úÖ Frontend deployed to S3"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_PRODUCTION }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: production-${{ github.sha }}
        run: |
          echo "üèóÔ∏è Building and pushing Docker image to ECR..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "‚úÖ Docker image pushed to ECR"

      - name: Deploy to ECS
        run: |
          echo "üöÄ Deploying to ECS production..."
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --force-new-deployment
          echo "‚úÖ ECS service updated"

      - name: Wait for deployment to complete
        run: |
          echo "‚è≥ Waiting for deployment to complete..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE
          echo "‚úÖ Deployment completed"

      - name: Run production tests
        run: |
          echo "üß™ Running production tests..."
          # Resolve ALB DNS name for the ECS service
          TARGET_GROUP_ARN=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text)
          ALB_ARN=$(aws elbv2 describe-target-groups \
            --target-group-arns "$TARGET_GROUP_ARN" \
            --query 'TargetGroups[0].LoadBalancerArns[0]' \
            --output text)
          SERVICE_URL=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns "$ALB_ARN" \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          # Wait for service to be ready
          sleep 60
          
          # Test health endpoint
          curl -f http://$SERVICE_URL/health || echo "‚ö†Ô∏è Health check failed"
          
          # Test basic functionality
          curl -f http://$SERVICE_URL/ || echo "‚ö†Ô∏è Root endpoint check failed"
          
          # Test API endpoints
          curl -f http://$SERVICE_URL/api/health || echo "‚ö†Ô∏è API health check failed"
          
          echo "‚úÖ Production tests completed"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Build frontend
        working-directory: frontend
        run: |
          npm ci
          npm run build

      - name: Deploy frontend to S3
        run: |
          echo "üì¶ Deploying frontend to S3..."
          aws s3 sync frontend/build/ s3://$S3_BUCKET/ --delete
          aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*" || echo "‚ö†Ô∏è CloudFront invalidation failed"
          echo "‚úÖ Frontend deployed to S3"

      - name: Update DNS records
        run: |
          echo "üåê Updating DNS records..."
          # Add your DNS update logic here if needed
          echo "‚úÖ DNS records updated"

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_PRODUCTION }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Terraform Init
        working-directory: terraform
        run: |
          echo "üîß Initializing Terraform..."
          terraform init
          echo "‚úÖ Terraform initialized"

      - name: Terraform Plan
        working-directory: terraform
        run: |
          echo "üìã Creating Terraform plan..."
          terraform plan -out=tfplan
          echo "‚úÖ Terraform plan created"

      - name: Terraform Apply
        working-directory: terraform
        run: |
          echo "üöÄ Applying Terraform changes..."
          terraform apply -auto-approve tfplan
          echo "‚úÖ Terraform changes applied"

  monitor-deployment:
    name: Monitor Deployment
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_PRODUCTION }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Monitor application health
        run: |
          echo "üìä Monitoring application health..."
          
          # Monitor staging if deployed
          if [ "${{ needs.deploy-staging.result }}" == "success" ]; then
            echo "üîç Monitoring staging deployment..."
            # Add your staging monitoring logic here
          fi
          
          # Monitor production if deployed
          if [ "${{ needs.deploy-production.result }}" == "success" ]; then
            echo "üîç Monitoring production deployment..."
            # Add your production monitoring logic here
          fi
          
          echo "‚úÖ Health monitoring completed"

  notify-deployment:
    name: Notify Deployment Results
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production, monitor-deployment]
    if: always()
    steps:
      - name: Comment PR with deployment results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              'deploy-staging': '${{ needs.deploy-staging.result }}',
              'deploy-production': '${{ needs.deploy-production.result }}',
              'monitor-deployment': '${{ needs.monitor-deployment.result }}'
            };
            let comment = '## üöÄ Deployment Results\n\n';
            comment += '### ‚úÖ Successful Deployments\n';
            Object.entries(results).forEach(([job, result]) => {
              if (result === 'success') {
                comment += `- **${job}**: ‚úÖ Deployed\n`;
              }
            });
            comment += '\n### ‚ùå Failed Deployments\n';
            Object.entries(results).forEach(([job, result]) => {
              if (result === 'failure') {
                comment += `- **${job}**: ‚ùå Failed\n`;
              }
            });
            const allPassed = Object.values(results).every(result => result === 'success' || result === 'skipped');
            if (allPassed) {
              comment += '\nüéâ **Deployment successful!** The application is now live.';
            } else {
              comment += '\n‚ö†Ô∏è **Some deployments failed.** Please review the failed jobs.';
            }
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Create deployment issue on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const issueTitle = 'üö® Deployment Failure Detected';
            const results = {
              'deploy-staging': '${{ needs.deploy-staging.result }}',
              'deploy-production': '${{ needs.deploy-production.result }}',
              'monitor-deployment': '${{ needs.monitor-deployment.result }}'
            };
            const failedJobs = Object.entries(results)
              .filter(([job, result]) => result === 'failure')
              .map(([job, result]) => `- **${job}**: ‚ùå Failed`)
              .join('\n');
            const issueBody = '## Deployment Failure Alert\n\n' +
              '**Timestamp:** ' + new Date().toISOString() + '\n' +
              '**Branch:** ' + context.ref + '\n' +
              '**Commit:** ' + context.sha + '\n\n' +
              '### Failed Jobs:\n' + failedJobs + '\n\n' +
              '### Next Steps:\n' +
              '1. Review the deployment logs\n' +
              '2. Check AWS resources and permissions\n' +
              '3. Verify application configuration\n' +
              '4. Re-run deployment after fixes\n\n' +
              '---\n' +
              '*This issue was automatically created by the deployment workflow.*';
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['deployment', 'failure', 'automation']
            });
